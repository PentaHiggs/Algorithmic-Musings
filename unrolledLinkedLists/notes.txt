I just realized the true usefulness of setters and getters, namely the ability to change the internals of an object while still keeping the externals the same.  More importantly, when you have a mutable object with many fields, often times only a subset of those states are actually valid states and if you let other classes and methods act directly on these fields, then you also have the trouble of having to remember how to ensure valid state whereas if you only access them through setters and getters, the setters and getters can both ensure valid state is maintained through each transition and that other code is resistant to changes in the internal implementations.  Namely, in my code at some point I had a friend class accessing methods of another class that was continuously morphing as I realized that certain design decisions were shortsighted and that I should store information differently, even though the external interface was set in stone from the beginning.  A perfect situation for the use of setters and getters!  Not to mention I realized that there was a lot of trickiness with managing state and ensuring it stays valid, and it's al lot of saved code to have all the state-management to be internal to the object that needs to maintain it instead of having code maintaing this state spilling out into methods of classes that use this class a member variable.  From what I understand, compilers will inline getters and setters whenever it's relatively reasonable, so is there any reason to not use them on anything?  Except maybe dumb structs consisting of just a few grouped related variables, it seems like it's always a good idea.


Problem realized:  Returning nodes might be a bad idea, because if we return a node then the user might decide to save this returned node to a variable.  In that case, then this node that was saved to a variable will be mutated!  Because of this, then I think we actually need to hide the nodes behind getters that lie in the list.  Namely, the list API might need to be as follows:

1. Rewind (returns the list to the original state, at its head)
2. Insert (Does as before, does not return anything, does not augment pointer)
3. Append (Is an insert, but inserts to the end of the list)
3. Delete (Does as before, does augment pointer to the next element after the deleted one)
4. Data   (Returns the value of the node at the current position in the list)

It's a bit unfortunate that the API has to be changed in that matter, but I think it's fine.  It's like a more traditional iterator now.  Maybe we can overload the dereferencing operator?  This is all not really modern C++, except for the use of classes and generics.  
